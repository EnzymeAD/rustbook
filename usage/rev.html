<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Reverse Mode</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="reverse-mode"><a class="header" href="#reverse-mode">Reverse Mode</a></h1>
<h1 id="autodiff-on-llvm-ir"><a class="header" href="#autodiff-on-llvm-ir">Autodiff on LLVM IR</a></h1>
<p>TODO: Typical LICM \(O(n)\) vs \(O(n^2)\) Enzyme example.
TODO: Talk about what makes this approach special and a good fit for Rust conceptually.</p>
<h2 id="changes-to-rust"><a class="header" href="#changes-to-rust">Changes to Rust</a></h2>
<p>TODO: Talk about the new attributes and define the semantics of these new attributes. Give examples.</p>
<h4 id="reverse-mode-1"><a class="header" href="#reverse-mode-1">Reverse Mode</a></h4>
<p>Both the in-place and "normal" variant return the gradient. The difference is that with <code>Active</code> the gradient is returned and with <code>Duplicated</code> the gradient is accumulated in-place.</p>
<h3 id="usage-story"><a class="header" href="#usage-story">Usage story</a></h3>
<p>Let us start by looking at the most basic examples we can think of:</p>
<p>\[ f(x,y) = x^2 + 3y \]</p>
<p>We have two input variables \(x\), \(y\) and a scalar return value.
The gradient is</p>
<p>\[ \nabla f = \Big[\frac{\partial f}{\partial x}, \frac{\partial f}{\partial y} \Big] = \big[2x, 3 \big] \]</p>
<p>Let's check for Enzyme (our compiler explorer does not handle Rust yet, so you'll have to trust me on this).</p>
<pre><code class="language-rust noplayground">    use std::autodiff::autodiff;
    #[autodiff(df, Reverse, Active, Active, Active)]
    fn f(x: f32, y: f32) -&gt; f32 {
        x * x + 3.0 * y
    }

    fn main() {
        let (x, y) = (5.0, 7.0);
        let (z, bx, by) = df(x, y, 1.0);
        assert_eq!(46.0, z);
        assert_eq!(10.0, bx);
        assert_eq!(3.0, by);
    }</code></pre>
<p>Enzyme actually generates the code on LLVM-IR level, but Rust is nicer to read, so I will pretend we would generate a Rust implementation:</p>
<pre><code class="language-rust ignore">fn f(x: f32, y: f32) -&gt; f32 {
  x * x + 3.0 * y
}
fn df(x: f32, y: f32) -&gt; (f32, f32, f32) {
  let d_dx = 2.0 * x;
  let d_dy = 3.0;
  let f = x * x + 3.0 * y;
  (d_dx, d_dy, f)
}</code></pre>
<p>Note that the last entry in the result tuple contains the original return value. However, we don't always pass things by value, so let's make sure we have a sensible solution:</p>
<pre><code class="language-rust ignore">#[autodiff(df, Reverse, Active, Duplicated, Active)]
fn f(x: f32, y: &amp;f32) -&gt; f32 {
  x * x + 3.0 * y
}</code></pre>
<p>(pay attention to <code>y</code>).</p>
<pre><code class="language-rust ignore">fn f(x: f32, y: f32) -&gt; f32 {
  x * x + 3.0 * y
}
fn df(x: f32, y: &amp;f32, d_dy: &amp;mut f32) -&gt; (f32, f32) {
  let d_dx = 2.0 * x;
  *d_dy += 3.0;
  let f = x * x + 3.0 * y
  (d_dx, f)
}</code></pre>
<p>In the case of references (or pointers) we do expect the user to create <code>d_dy</code>.</p>
<p>We could obviously zero-initialize a float for the user, but let's assume the constructor is complex due to involving a double-linked-list or ffi, so we can't guarantee that on the compiler side. As an alternative motivation, imagine that we call <code>df</code> 5 times in a loop. It is clear that in this case the accumulated gradients should be 5 times higher too, which won't happen if we set <code>d_dy = 3.0</code> each time, instead of using <code>+=</code>. Yet another reason would be higher-order derivatives (todo: just refer to literature?).</p>
<p>Now that we got back from this rabbit hole, let's go wild and train a neural network on our local national lab server:</p>
<pre><code class="language-rust ignore">#[autodiff(backprop, Reverse, Duplicated, Duplicated, Active)]
fn training_loss(images: &amp;[f32], weights: &amp;[f32]) -&gt; f32 {
  let loss = do_some_math(images, weights);
  loss
}</code></pre>
<p>Now Enzyme gives us:</p>
<pre><code class="language-rust ignore">fn training_loss(images: &amp;[f32], weights: &amp;[f32]) -&gt; f32 {
  let loss = do_some_math(images, weights);
  loss
}
fn backprop(images: &amp;[f32], dimages: &amp;mut [f32], weights: &amp;[f32], dweights: &amp;mut [f32]) -&gt; f32 {
  enzyme_update_inplace_dx(dimages);
  enzyme_update_inplace_dy(dweights);
  let loss = do_some_math(images, weights);
  loss
}</code></pre>
<p><em>Uuuuhm. Yeah?</em> We want to minimize our loss, so let's do <code>weights -= learning_rate * dweights;</code></p>
<p>We also just learned how we can update our images through <code>dimages</code>, but unless you know how to shape the world around you that's pretty useless, so we just wasted a good amount of our compute time for not needed gradients. Let's try again:</p>
<pre><code class="language-rust ignore">#[autodiff(backprop, Reverse, Const, Duplicated, Active)]
fn training_loss(images: &amp;[f32], weights: &amp;[f32]) -&gt; f32 {
  let loss = do_some_math(images, weights);
  loss
}</code></pre>
<p>After all, we shouldn't modify our train and test images to improve our accuracy, right? So we now generate:</p>
<pre><code class="language-rust ignore">fn training_loss(images: &amp;[f32], weights: &amp;[f32]) -&gt; f32 {
  let loss = do_some_math(images, weights);
  loss
}
fn backprop(images: &amp;[f32], weights: &amp;[f32], dweights: &amp;mut [f32]) {
  enzyme_update_inplace_dy(dweights);
  let loss = do_some_math(x,y);
  loss
}</code></pre>
<p>Great. No more random dimages that we don't know how to handle. Perfection? Almost:</p>
<pre><code class="language-rust ignore">#[autodiff(backprop, Reverse, Const, Duplicated, DuplicatedNoNeed)]
fn training_loss(images: &amp;[f32], weights: &amp;[f32]) -&gt; f32 {
  let loss = do_some_math(images, weights);
  loss
}</code></pre>
<p>Happy to accept better names than <code>DuplicatedNoNeed</code>. Either way, now we have:</p>
<pre><code class="language-rust ignore">fn training_loss(images: &amp;[f32], weights: &amp;[f32]) -&gt; f32 {
  let loss = do_some_math(images, weights);
  loss
}
fn backprop(images: &amp;[f32], weights: &amp;[f32], dweights: &amp;mut [f32]) {
  enzyme_update_inplace_dy(dweights);
}</code></pre>
<p>We run backprop to get the gradients to update our weights, tracking of the loss while training is optional. Keep in mind that this will allow Enzyme to do some slightly advanced dead code elimination, but at the end of the day Enzyme will still need to compute most of <code>do_some_math(x, y)</code> in order to calculate <code>dy</code>. So how much runtime you save by not asking for loss will depend on your application. We won't introduce a new motivation for our last example, but let's assume we have reasons to only want <code>dweights</code>, but do not care about the original weights anymore.</p>
<pre><code class="language-rust ignore">#[autodiff(backprop, Reverse, Const, DuplicatedNoNeed, DuplicatedNoNeed)]
fn training_loss(images: &amp;[f32], weights: &amp;[f32]) -&gt; f32 {
  let loss = do_some_math(images, weights);
  loss
}</code></pre>
<p><code>DuplicatedNoNeed</code> allows Enzyme to reuse the memory of our <code>weights</code> variable as a scratchspace. That means it might increase the performance, but in exchange the variable shall not be assumed to have meaningful values afterwards. That's obviously only valid in Julia, C++, etc., but not in Rust. We had some discussion on whether this can be represented as MaybeUninit or Option but didn't got to a conclusion yet. (WIP)</p>
<pre><code class="language-rust ignore">fn training_loss(images: &amp;[f32], weights: &amp;[f32]) -&gt; f32 {
  let loss = do_some_math(images, weights);
  loss
}
fn backprop(images: &amp;[f32], weights: &amp;[f32], dweights: &amp;mut [f32]) {
  enzyme_update_inplace_dy(dweights);
}</code></pre>
<p>And as the very last one, Enzyme follows Jax and all the other AD tools by allowing batched backpropagation:</p>
<pre><code class="language-rust ignore">#[autodiff(backprop, Reverse(2), Const, Duplicated, DuplicatedNoNeed)]
fn training_loss(images: &amp;[f32], weights: &amp;[f32]) -&gt; f32 {
  let loss = do_some_math(images, weights);
  loss
}</code></pre>
<p>We don't expose batchmode on the Rust side yet, let's do one step after the other.</p>
<pre><code class="language-rust ignore">fn training_loss(images: &amp;[f32], weights: &amp;[f32]) -&gt; f32 {
  let loss = do_some_math(images, weights);
  loss
}
fn backprop(images: (&amp;[f32], &amp;[f32]), weights: (&amp;[f32], &amp;[f32]), dweights: (&amp;mut f[f32], &amp;mut [f32])) {
  enzyme_update_inplace_dy(dweights.0);
  enzyme_update_inplace_dy(dweights.1);
}</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../usage/fwd.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../usage/higher.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../usage/fwd.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../usage/higher.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
